apply plugin: 'java-library'
apply plugin: 'kotlin'
//需要发布的时候开启下面配置
//使用参考：https://github.com/vanniktech/gradle-maven-publish-plugin/blob/main/docs/base.md
apply plugin: 'com.vanniktech.maven.publish'

allprojects {
    plugins.withId("com.vanniktech.maven.publish") {
        mavenPublish {
            sonatypeHost = "S01"
        }
    }
}

java {
    sourceCompatibility JavaVersion.VERSION_1_8
    targetCompatibility JavaVersion.VERSION_1_8
}

dependencies {
    def retrofit_version = '2.6.4'
    def okhttp_version = '3.12.12'

    testImplementation 'junit:junit:4.+'
    /*部分类用到了Android SDK相关的类*/
    compileOnly 'com.google.android:android:4.1.1.4'

    implementation "com.squareup.okhttp3:okhttp:$okhttp_version"

    /**
     *  [Retrofit]  Http客户端实现
     *  <proguard>
     *  https://github.com/square/retrofit
     *      间接引入：
     *       [OkHttp] <proguard>
     *       [Okio] <proguard>
     *  Retrofit requires at minimum Java 8+ or Android API 21+.
     *  高版本只支持ApiLevel 21；
     *  支持到4.4 retrofit + okhttp的版本不能太高：okhttp3_version = "3.14.4" retrofit_version = "2.7.1"
     */
    implementation "com.squareup.retrofit2:retrofit:$retrofit_version"

    /*关于日志：如果开启了debug模式，再检测用户是否添加了日志依赖，如果添加则引入*/

    /**
     *  [logging-interceptor] okhttp请求日志打印拦截器，版本号与okhttp版本一致
     *  https://github.com/square/okhttp/tree/master/okhttp-logging-interceptor
     */
    compileOnly "com.squareup.okhttp3:logging-interceptor:$okhttp_version"


    /*关于Converter，如果用户依赖了moshi，则优先使用moshi，如果没有再检查Gson*/

    //retrofit 如果是kotlin，则考虑使用moshi
    compileOnly "com.squareup.retrofit2:converter-moshi:$retrofit_version"

     /**
     *  [Retrofit Converter Gson] 使用Gson作为Retrofit的序列化和反序列化工具
     *  <proguard>
     *  https://github.com/square/retrofit/wiki/Converters
     *  https://github.com/google/gson
     */
    compileOnly "com.squareup.retrofit2:converter-gson:$retrofit_version"

}
tasks.withType(Javadoc) {
    options.encoding = "utf-8"
    options.charSet = "utf-8"
}

///**
// * kotlin java library 生成源码和javadoc jar的任务
// */
//
//// 生成源码产物
//task sourcesJar(type: Jar, dependsOn: classes) {
//    classifier = 'sources'
//    from sourceSets.main.allSource
//}
//
//// 生成 javadoc 产物
//task javadocJar(type: Jar, dependsOn: dokkaJavadoc) {
//    classifier = 'javadoc'
//    from javadoc.destinationDir
//}

/*以下是生成混淆jar的代码，但是不知道怎么让打包的时候使用混淆的jar*/

//import proguard.gradle.ProGuardTask

//buildscript {
//    repositories {
//        mavenCentral()
//    }
//    dependencies {
//        classpath "com.guardsquare:proguard-gradle:7.1.0"
//    }
//}

//task makeJar(type: ProGuardTask,dependsOn:jar) {
//
//    def jarName = "$POM_ARTIFACT_ID-$VERSION_NAME"+".jar"
//    def inputFolder = "$buildDir/libs"
//    def obfuscatedFolder = "$buildDir/obfuscated"
//    def inputJarPath = "$inputFolder/$jarName"
//    def obfuscatedJarPath = "$obfuscatedFolder/$jarName"
//
//    delete obfuscatedFolder//删除之前编译混淆jar包
//    injars inputJarPath //项目编译但未混淆的jar
//    outjars obfuscatedJarPath//混淆后的jar路径
//
//    // 配置ProGuardTask
//    printseeds "$obfuscatedFolder/seeds.txt"
//    printmapping "$obfuscatedFolder/mapping.txt"
//    configuration 'proguard-rules.pro'// 混淆配置文件
//
//    dontwarn //避免在混淆过程中因为警告导致编译失败
////    是否需要压缩，完全根据实际的来
////    dontshrink //不压缩，避免没有被应用的代码被删掉
//
//    doLast {
//        // 删除原有的class文件
//        delete inputJarPath
//        // 将混淆class文件复制过去
//        copy {
//            from obfuscatedJarPath
//            into inputFolder
//        }
//    }
//}
//
////在jar任务之后执行 后续任务,在发布的时候需要混淆就可以打开词句代码
//jar.finalizedBy(makeJar)
